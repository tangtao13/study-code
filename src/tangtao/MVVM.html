<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    </head>
    <body>
        <div id="app">
            <h3>姓名</h3>
            <p>{{name}}</p>
            <h3>年龄</h3>
            <p>{{age}}</p>
        </div>
    </body>
</html>
<script>
    document.addEventListener(
        'DOMContentLoaded',
        function () {
            let opt = {el: '#app', data: {name: '检索中...', age: 30}};
            let vm = new Vue(opt);
            setTimeout(() => {
                opt.data.name = '王永峰';
            }, 2000);
        },
        false
    );

    class Vue {
        constructor(opt) {
            this.opt = opt;
            this.observe(opt.data);
            let root = document.querySelector(opt.el);
            this.compile(root);
        }
        observe(data) {
            Object.keys(data).forEach((key) => {
                let obv = new Observer();
                data['_' + key] = data[key];
                //通过getter setter暴露for 循环中的作用域下的obv,闭包产生
                Object.defineProperty(data, key, {
                    get() {
                        Observer.target && obv.addSubNode(Observer.target);
                        return data['_' + key];
                    },
                    set(newVal) {
                        obv.updata(newVal);
                        data['_' + key] = newVal;
                    },
                });
            });
        }

        compile(node) {
            [].forEach.call(node.childNodes, (child) => {
                if (!child.firstElementChild && /\{\{(.*)\}\}/.test(child.innerHTML)) {
                    //RegExp.$1是RegExp的一个属性,指的是与正则表达式匹配的第一个 子匹配(以括号为标志)字符串
                    let key = Regexp.$1.trim();
                    child.innerHTML = child.innerHTML.repalce(
                        new Regexp('\\{\\{\\s*' + key + '\\s\\}\\}', 'gm'),
                        this.opt.data[key]
                    );
                    Observer.target = child;
                    //触发get存取器，收集依赖
                    this.opt.data[key];
                    Observer.target = null;
                } else if (child.firstElementChild) {
                    this.compile(child);
                }
            });
        }
    }

    class Observer {
        constructor() {
            this.subNode = [];
        }
        addSubNode(node) {
            this.subNode.push(node);
        }
        update(newVal) {
            this.subNode.forEach((node) => {
                node.innerHTML = newVal;
            });
        }
    }
</script>
