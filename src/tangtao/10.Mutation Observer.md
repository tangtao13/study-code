<!--
 * @Author: myname
 * @Date: 2021-05-28 10:28:55
 * @LastEditors: Do not edit
 * @LastEditTime: 2021-05-28 16:40:27
-->

### MutationObserver API

###### 目录

1.  概述

          Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容
        的变动，这个 API 都可以得到通知。

          概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有
        一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则
        是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。

          这样设计是为了应付 DOM 变动频繁的特点,而且只触发一次

        Mutation Observer 有以下特点。
            - 它等待所有脚本任务完成后，才会运行（即异步触发方式）
            - 它把 DOM 变动记录封装成一个数组进行处理，而不是一条条个别处理 DOM变动。
            - 它既可以观察 DOM 的所有类型变动，也可以指定只观察某一类变动。

2.  MutationObserver 构造函数

    ```javascript
    var observer = new MutationObserver(function (mutations, observer) {
        mutations.forEach(function (mutation) {
            console.log(mutation);
        });
    });
    ```

3.  MutationObserver 的实例方法

    -   Observe()  
         observe()方法用来启动监听，它接受两个参数。第一个参数：所要观察的 DOM 节点,  
         第二个参数:一个配置对象，指定所要观察的特定变动。

            ````javascript
            var article = document.querySelector('article');

            var  options = {
            'childList': true,
            'attributes':true
            } ;

            observer.observe(article, options);


            // 开始监听文档根节点（即<html>标签）的变动
            mutationObserver.observe(document.documentElement, {
                attributes: true,
                characterData: true,
                childList: true,
                subtree: true,
                attributeOldValue: true,
                characterDataOldValue: true
            });
            ```

-   disConnect()  
    disconnect()方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。
-   takeRecords()  
    takeRecords()方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。

4.  MutationRecord 对象  
    DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。  
    Mutation Observer 处理的就是一个个 MutationRecord 实例所组成的数组。  
    MutationRecord 对象包含了 DOM 的相关信息，有如下属性：
    -   type：观察的变动类型（attributes、characterData 或者 childList）。
    -   target：发生变动的 DOM 节点。
    -   addedNodes：新增的 DOM 节点。
    -   removedNodes：删除的 DOM 节点。
    -   previousSibling：前一个同级节点，如果没有则返回 null。
    -   nextSibling：下一个同级节点，如果没有则返回 null。
    -   attributeName：发生变动的属性。如果设置了 attributeFilter，则只返回预先指定的属性。
    -   oldValue：变动前的值。这个属性只对 attribute 和 characterData 变动有效，如果发生 childList 变动，则返回 null。
5.  应用示例

-   子元素变动

```javascript
var callback = function (records) {
    records.map(function (record) {
        console.log('Mutation type: ' + record.type);
        console.log('Mutation target: ' + record.target);
    });
};

var mo = new MutationObserver(callback);

var option = {
    childList: true,
    subtree: true,
};

mo.observe(document.body, option);
```

-   属性的变动

```javascript
var callback = function (records) {
    records.map(function (record) {
        console.log('Previous attribute value: ' + record.oldValue);
    });
};

var mo = new MutationObserver(callback);

var element = document.getElementById('#my_element');

var options = {
    attributes: true,
    attributeOldValue: true,
};

mo.observe(element, options);
```

-   取代 DOMContentLoaded 事件

```javascript
//使用MutationObserver对象封装一个监听 DOM 生成的函数。
(function (win) {
    'use strict';

    var listeners = [];
    var doc = win.document;
    var MutationObserver = win.MutationObserver || win.WebKitMutationObserver;
    var observer;

    function ready(selector, fn) {
        // 储存选择器和回调函数
        listeners.push({
            selector: selector,
            fn: fn,
        });
        if (!observer) {
            // 监听document变化
            observer = new MutationObserver(check);
            observer.observe(doc.documentElement, {
                childList: true,
                subtree: true,
            });
        }
        // 检查该节点是否已经在DOM中
        check();
    }

    function check() {
        // 检查是否匹配已储存的节点
        for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            // 检查指定节点是否有匹配
            var elements = doc.querySelectorAll(listener.selector);
            for (var j = 0; j < elements.length; j++) {
                var element = elements[j];
                // 确保回调函数只会对该元素调用一次
                if (!element.ready) {
                    element.ready = true;
                    // 对该节点调用回调函数
                    listener.fn.call(element, element);
                }
            }
        }
    }

    // 对外暴露ready
    win.ready = ready;
})(this);

// 使用方法
ready('.foo', function (element) {
    // ...
});
```

click -> mousedown,mouseup,click  
dbclick -> mousedown,mouseup,click,dbclick

鼠标进入一个节点时触发  
 mouseenter ->只会触发一次  
 mouseover ->只要鼠标在节点移动，mouseover 事件会在子节点上触发多次

鼠标离开一个节点时触发  
 mouseout -> 在父元素内部离开一个子元素时  
 mouseleave -> 只会触发一次

```javascript
// HTML 代码如下
// <div id="output" style="min-height: 200px;border: 1px solid black;">
//   文件拖拉到这里
// </div>

var div = document.getElementById('output');

div.addEventListener(
    'dragenter',
    function (event) {
        div.textContent = '';
        event.stopPropagation();
        event.preventDefault();
    },
    false
);

div.addEventListener(
    'dragover',
    function (event) {
        event.stopPropagation();
        event.preventDefault();
    },
    false
);
div.addEventListener('drop', function (e) {
    e.preventDefault();
    e.stopPropagation();

    var fileList = e.dataTransfer.files;
    if (fileList.length > 0) {
        var file = fileList[0];
        var reader = new FileReader();
        reader.onloadend = function (e) {
            if (e.target.readyState === FileReader.DONE) {
                var content = reader.result;
                div.innerHTML = 'File: ' + file.name + '\n\n' + content;
            }
        };
        reader.readAsBinaryString(file);
    }
});

function throttle(fn, wait) {
    var time = Date.now();
    return function () {
        if (time + wait - Date.now() < 0) {
            fn();
            time = Date.now();
        }
    };
}

window.addEventListener('scroll', throttle(callback, 1000));
```
