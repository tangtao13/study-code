<!--
 * @Author: myname
 * @Date: 2021-06-22 14:00:34
 * @LastEditors: Do not edit
 * @LastEditTime: 2021-06-22 15:32:15
-->

#### 浏览器进程 多进程架构

-   浏览器进程： 主要负责页面展示，用户交互，子进程管理，文件存储等功能
-   网络进程： 主要为浏览器进程和渲染进程提供网络请求资源功能
-   渲染进程： 核心任务是将 HTML、CSS、JavaScript 转换为用户可以预知交互的网页

---

-   从输入 url 按下回车到页面展示的过程中发生了什么？

    -   从用户发送 URL 请求到页面开始解析的这个过程，就是网络请求部分

    1. 浏览器进程把用户输入的 url 组装成完整的 url 后交给网络进程
    2. 网络进程通脱 DNS 解析拿到 IP 地址，然后与服务器建立 TCP 链接，并发送 HTTP 请求，  
       在收到服务器端响应的数据后，开始 解析处理；
    3. 网络进程收到 HTML 类型的数据后，通过提交文档把数据交给渲染进程，准备进入渲染阶段；

-   页面开始解析到页面完整展示的过程 -- 渲染过程

    -   每个阶段都有**获取输入内容、处理内容、生成输出内容**这样的周期

    1. 构建 DOM 树  
       DOM 把文档作为一个树形结构，把树的每个节点表示一个 HTML 标签或标签内的文本项。  
       DOM 是表述 HTML 的内部数据结构，它会将 WEB 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。  
       构建 DOM 树的过程：  
       DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是 ， **DOM 是保存在内存重的树状结构**，  
        **可以通过 JavaScript 来查询或修改其内容**

        - 输入： 从网络请求或者缓存中拿到 的 HTML 文件
        - 处理： 通过 HTML 解析器解析生成 DOM 树，大概过程：
            - 拿到 HTML 文件的字节流数据，将这些字节数据转换为字符串，
            - 将这些字符串转换为标记（token）
            - 把这些标记进行**词法分析**转换为**DOM**节点
            - 将 DOM 节点构建为一棵 DOM 树
        - 输出： 输出一个树状结构的 DOM，即 DOM 树。

    2. 样式计算（解析 CSS）  
       样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式。  
       样式计算的过程：
        - 输入：
            1. 通过 link 引用的外部 CSS 文件；
            2. \<style\> 标签内的 CSS;
            3. 元素的 style 属性内嵌的 CSS
        - 处理：
            1. 把 CSS 转换为浏览器能够理解的结构-- styleSheets,styleSheets 具有 2 个作用：
                - 提供给 JavaScript 操作样式表的能力
                - 为布局树的合成提供基础的样式信息
            2. 转换样式表中的属性值，使其标准化；即需要把所有的值转换为渲染引擎容易理解的、标准化的计算值
            3. 计算出 DOM 树中每个节点的具体样式，在这个过程中需要遵守 CSS 的继承规则和层叠规则：
                - CSS 继承就是每个 DOM 节点都包含有父节点的样式
                - 层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。
        - 输出：  
           每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构
    3. 获取布局树  
       计算出 DOM 树中可见元素的集合位置，也就是布局（Layout）。  
        布局阶段：
        - 输入：DOM 树和 CSSOM 树
        - 处理：
            1. 构建一棵只包含可见元素的布局树
                - 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中
                - 而不可见的节点会被布局树忽略掉，如属性包含 display:none 的元素不会被包含进布局树
            2. 布局计算： 计算布局树节点的坐标位置，然后写回布局树中
        - 输出： 包含 DOM 元素样式和位置的布局树
    4. 生成图层树  
       过程：

        - 输入： 布局树
        - 处理： 将特定节点生成专用图层
            - 拥有层叠上下文属性的元素会被提升为单独的一层
            - 需要裁减的地方会被创建为图层
        - 输出： 图层树

    5. 图层绘制
        - 输入：图层树
        - 处理：
            - 渲染引擎对图层树中每个图层进行绘制
            - 拆分成绘制指令，生成绘制列表，提交到合成线程
        - 输出：绘制列表
    6. 栅格化处理

        - 输入：绘制列表
        - 处理：
            - 根据视口，合成线程会将图层划分为 图块
            - 合成线程会按照视口附近的图块来优先生成 位图
        - 输出：保存在 GPU 内存中的位图合成显示

    7. 合成显示
        - 一旦所有图块都被栅格化，合成线程 就会生成一个绘制图块的命令——DrawQuad，然后将该命令提交给  
          浏览器进程
        - 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后将其页面内容绘  
          制到内存中，最后 再将内存显示在屏幕上。

-   渲染流程总结
    1.  浏览器不能直接理解 HTML 数据，所以第一步是 渲染进程将其转换为浏览器能够理解的 DOM 树结构
    2.  生成 DOM 树后，渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式
    3.  创建布局树，并计算 DOM 元素的布局信息，使其都保存在 布局树 中
    4.  对布局树进行分层，并生成 图层树
    5.  为每个图层生成 绘制列表，并将其提交到合成线程
    6.  合成线程 将图层分成 图块，并在光栅化线程池中将图块转换成 位图
    7.  合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令消息生成页面，并显示到显示器上
