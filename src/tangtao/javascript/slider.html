<!--
 * @Author: myname
 * @Date: 2021-06-02 15:57:25
 * @LastEditors: Do not edit
 * @LastEditTime: 2021-06-02 19:22:32
-->
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <style>
            .slider {
                border-radius: 5px;
                background: #e0e0e0;
                background: linear-gradient(left top, #e0e0e0, #eeeeee);
                width: 310px;
                height: 15px;
                margin: 5px;
            }

            .thumb {
                width: 10px;
                height: 25px;
                border-radius: 3px;
                position: relative;
                left: 10px;
                top: -5px;
                background: blue;
                cursor: pointer;
            }
        </style>
    </head>

    <body>
        <div id="slider" class="slider">
            <div class="thumb"></div>
        </div>

        <script>
            let thumb = slider.querySelector('.thumb');

            thumb.onmousedown = function (event) {
                event.preventDefault(); // prevent selection start (browser action)

                let shiftX = event.clientX - thumb.getBoundingClientRect().left;
                // shiftY not needed, the thumb moves only horizontally

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);

                function onMouseMove(event) {
                    let newLeft = event.clientX - shiftX - slider.getBoundingClientRect().left;

                    // the pointer is out of slider => lock the thumb within the bounaries
                    if (newLeft < 0) {
                        newLeft = 0;
                    }
                    let rightEdge = slider.offsetWidth - thumb.offsetWidth;
                    if (newLeft > rightEdge) {
                        newLeft = rightEdge;
                    }

                    thumb.style.left = newLeft + 'px';
                }

                function onMouseUp() {
                    document.removeEventListener('mouseup', onMouseUp);
                    document.removeEventListener('mousemove', onMouseMove);
                }
            };

            thumb.ondragstart = function () {
                return false;
            };
        </script>
    </body>
</html>

<script>
    let thumb = slider.querySelector('.thumb');
    let shiftX;

    thumb.onpointerdown = function (event) {
        event.preventDefault(); // 阻止开始选择（浏览器行为）

        shiftX = event.clientX - thumb.getBoundingClientRect().left;

        thumb.setPointerCapture(event.pointerId);
    };

    thumb.onpointermove = function (event) {
        let newLeft = event.clientX - shiftX - slider.getBoundingClientRect().left;

        // 如果指针移出了滑块 => 调整 left 来防止其超出边界
        if (newLeft < 0) {
            newLeft = 0;
        }
        let rightEdge = slider.offsetWidth - thumb.offsetWidth;
        if (newLeft > rightEdge) {
            newLeft = rightEdge;
        }

        thumb.style.left = newLeft + 'px';
    };

    thumb.ondragstart = () => false;

    /**
    A variant of the test that considers the element visible if it's no more than
    one page after/behind the current screen.
    */

    function isVisible(elem) {
        let coords = elem.getBoundingClientRect();

        let windowHeight = document.documentElement.clientHeight;

        // top elem edge is visible OR bottom elem edge is visible
        let topVisible = coords.top > 0 && coords.top < windowHeight;
        let bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;

        return topVisible || bottomVisible;
    }

    function isVisible(elem) {
        let coords = elem.getBoundingClientRect();

        let windowHeight = document.documentElement.clientHeight;

        let extendedTop = -windowHeight;
        let extendedBottom = 2 * windowHeight;

        // top visible || bottom visible
        let topVisible = coords.top > extendedTop && coords.top < extendedBottom;
        let bottomVisible = coords.bottom < extendedBottom && coords.bottom > extendedTop;

        return topVisible || bottomVisible;
    }
</script>
