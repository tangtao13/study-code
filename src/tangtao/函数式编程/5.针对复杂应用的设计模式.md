<!--
 * @Author: myname
 * @Date: 2021-04-27 10:54:01
 * @LastEditors: Do not edit
 * @LastEditTime: 2021-04-27 15:01:06
-->

#### 一种更安全的解决方式

```javascript
class Wrapper {
    contructor(value) {
        this._value = value;
    }
    //map :: (A -> B) -> A -> B
    map(fn) {
        return fn(this.val);
    }

    toString() {
        return `Wrapper ( ${this.value} )`;
    }
}

//fmap :: (A -> B) -> Wrapper[A] -> Wrapper[B]
Wrapper.prototype.fmap = function (fn) {
    return Wrapper(fn(this.val));
};

//wrap :: A -> Wrapper(A)
const wrap = (val) => new Wrapper(val);
```

---

1. 定义：从本质上讲，Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。
2. 属性约束条件：
    - 必须是无副作用。若映射 R.identity 函数可以获得上下文中相同的值，即可证明 Functor 是无副作用的：  
       wrap('Get Functional).fmap(R.identity); // -> Wrapper('Get Functional')
    - 必须是可组合的。这个属性的意思是 fmap 函数的组合，与分别 fmap 函数式一样的。如下：
      two.fmap(R.compose(plus3,R.tap(infoLogger))).fmap(R.identity)

---

#### 使用 Monad 解决函数式的错误处理

###### 1. 从控制流到数据流

    以下 2 个概念很重要：

-   Monad ---- 为 Monadic 操作提供抽象接口
-   Monadic 类型 --- 该接口的具体实现

Monadic 需要遵循以下的接口定义：

-   类型构造函数 --- 创建 Monadic 类型（类似于 Wrapper 的构造函数）
-   unit 函数 --- 可将特定类型的值放入 Monadic 结构中（类似于 wrap 和前面看到的 empty 函数）。对于 Monad 的实现来说，该
    函数也被称为 of 函数。
-   bind 函数 --- 可以链式操作（这就是 Functor 的 fmap，也被称为 flatmap）从现在开始，后文将使用更简短的 map。顺便说一句
    ，这个 bind 函数和第四章提到的‘函数绑定’概念完全是两回事。
-   join 函数 --- 将两层 Monadic 结构合并成一层。这会对嵌套返回的 Monad 函数特别有用

```javascript
class Wrapper {
    //类型构造器
    constructor(value) {
        this._value = value;
    }
    //unit函数
    static of(value) {
        return new Wrapper(value);
    }
    //bind函数（Functor）
    map(f) {
        return Wrapper.of(f(this.value));
    }
    //压平嵌套的Wrapper
    join() {
        if (!this.value instanceof Wrapper) {
            return this;
        }
        return this.value.join();
    }
    //返回一个当前结构的文本描述
    toString() {
        return `Wrapper (${this.value})`;
    }
}

//例子
Wrapper.of('hello Mondas!').map(R.toUpper).map(R.identity); // Wrapper('HELLO MONDAS!')

// 扁平化Monadic 结构
// findObject :: DB -> String -> Wrapper
const findObject = R.curry(function (db, id) {
    return Wrapper.of(find(db, id));
});
// getAddress :: Student -> Wrapper
const getAddress = function (student) {
    return Wrapper.of(student.map(R.prop('address')));
};

const studentAddress = R.compose(getAddress, findObject(DB('student')));
studentAddress('444-44-4444').join().get();
```

---

#### Monad 实例： Maybe，Either, IO

除了用来包装有效值，Monadic 的结构也可用于建模 null 或者 undefined。函数式编程通常使用 Maybe 和 Either 来做下列事情。

-   隔离不纯
-   合并判空逻辑
-   避免异常
-   支持函数组合
-   中心化逻辑，用于提供默认值

1. 用 Maybe 合并判空
